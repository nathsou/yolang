
let SIZEOF_U32 = 4;

struct Array {
  start: Ptr<u32>,
  length: u32,
  capacity: u32,
}

fn read(array, n) unsafe {
  *(((array.start as u32) + n * SIZEOF_U32) as Ptr<u32>)
}

fn write(array, n, val) unsafe {
  *(((array.start as u32) + n * SIZEOF_U32) as Ptr<u32>) = val;
}

fn push(array, val) unsafe {
  write(array, array.length, val);
  array.length = array.length + 1;
}

fn checkPrimeSieve(primes, n) {
  mut i = 0;
  mut p = read(primes, i);

  while p * p <= n {
    if n % p == 0 { return; }
    i = i + 1;
    p = read(primes, i);
  }

  // add this prime to the sieve
  push(primes, n);
}

fn countPrimesLessThan(m) {
  mut primes = Array {
    // right after the shadow stack
    start: 65536 as Ptr<u32>,
    length: 0,
    capacity: 100000
  };

  // 2 is the first prime
  push(primes, 2);

  mut i = 3;
  while i <= m {
    checkPrimeSieve(primes, i);
    i = i + 2;
  }

  primes.length
}

fn main() {
  countPrimesLessThan(1000000)
}