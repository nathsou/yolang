
let SIZEOF_U32 = 4;

struct Array {
  start: Ptr<u32>,
  length: u32,
  capacity: u32,
}

impl Array {
  fn read(self, n) unsafe {
    *(((self.start as u32) + n * SIZEOF_U32) as Ptr<u32>)
  }

  fn write(self, n, val) unsafe {
    *(((self.start as u32) + n * SIZEOF_U32) as Ptr<u32>) = val;
  }

  fn push(self, val) {
    self.write(self.length, val);
    self.length = self.length + 1;
  }
}

fn checkPrimeSieve(primes, n) {
  mut i = 0;
  mut p = primes.read(i);

  while p * p <= n {
    if n % p == 0 { return; }
    i = i + 1;
    p = primes.read(i);
  }

  // add this prime to the sieve
  primes.push(n);
}

fn countPrimesLessThan(m) {
  mut primes = Array {
    // right after the shadow stack
    start: 65536 as Ptr<u32>,
    length: 0,
    capacity: 100000
  };

  // 2 is the first prime
  primes.push(2);

  mut i = 3;
  while i <= m {
    checkPrimeSieve(primes, i);
    i = i + 2;
  }

  primes.length
}

fn main() {
  countPrimesLessThan(1000000)
}